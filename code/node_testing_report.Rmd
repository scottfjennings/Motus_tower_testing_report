---
title: "Node testing"
author: "Scott Jennings and David Lumpkin"
date: "2022-10-20"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      error = FALSE,
                      warning = FALSE)
```



```{r }




library(tidyverse)
library(lubridate)
library(here)
library(caret) # for cross-validation


options(scipen = 999)
df <- readRDS(here("data/node_data/combined_test_data"))

```

Motus nodes can be useful for understanding small scale movements of tagged animals. However, to make the best use of these tools requires some understanding of the relationships between the signal strength as detected by the node and the distance between tag and node.


We have collected data to understand these relationships by placing nodes and then carrying a transmitting tag on a standardized grid route around the nodes. We recorded tag location with a GPS unit also carried during the test. For the first tests we placed 3 nodes in an approximate right triangle with the short sides about 100m. We then carried tags along a grid that extended about 50m outside the triangle, as shown below where the larger points indicate the node locations and the smaller points is the testing route. 



```{r }
df %>% 
  filter(date == "2022-10-25") %>% 
  ggplot() +
  geom_path(aes(x = longitude, y = latitude)) +
  geom_point(aes(x = longitude, y = latitude, color = NodeID, shape = travel.mode)) +
  geom_jitter(aes(x = LonNode, y = LatNode, color = NodeID), size = 5, data = df %>% filter(date == "2022-10-25") %>% distinct(NodeID, LonNode, LatNode)) +
  theme_bw() +
  labs(x = "",
       y = "")

```

```{r }
df %>% 
  filter(date == "2022-12-06") %>% 
  ggplot() +
  geom_path(aes(x = longitude, y = latitude)) +
  geom_jitter(aes(x = longitude, y = latitude, color = NodeID)) +
  geom_jitter(aes(x = LonNode, y = LatNode, color = NodeID), size = 5, data = df %>% filter(date == "2022-12-06") %>% distinct(NodeID, LonNode, LatNode)) +
  theme_bw() +
  labs(x = "",
       y = "") +
  facet_wrap(~travel.mode)

```


```{r }

# ggplot(df) + geom_density(aes(Signal)) + theme_bw() + labs(x = "Signal strength")

```


We expect the radio signal strength to decrease with distance based on an exponential decay function. Viewing the raw data from these nodes, we see that the data roughly match this expectation.
```{r}
ggplot(df) +
  geom_point(aes(x = ant.tag.distance, y = Signal)) +
  facet_wrap(~NodeID) +
  labs(x = "Tag-node distance (m)",
       y = "Signal strength") +
  theme_bw()

#ggsave(here("figures/node_test_1_2.png"))
```



We can do some simple visualizations to evaluate how well signal strength predicts distance. To do this, we can randomly take 90% of the data and fit an exponential decay function to that subset. Then we can use that model to predict the distance for the remaining 10% of the data. For this testing we used the same model as Paxton et al. (2022):  

RSS ∼ a ∗ exp(-S ∗ distance) + K  

where K = horizontal asymptote of RSS values, a = intercept, S = decay factor.  



```{r}

distance_tester <- function(zdf) {

zsize = floor(nrow(zdf) * 0.9)

df_test <- sample_n(zdf, size = zsize)


exp.mod <- nls(Signal ~ SSasymp(ant.tag.distance, Asym, R0, lrc), data = df_test)

## 
a <- coef(exp.mod)[["R0"]]
S <- exp(coef(exp.mod)[["lrc"]])
K <- coef(exp.mod)[["Asym"]]

# Final Model
nls.mod <- nls(Signal ~ a * exp(-S * ant.tag.distance) + K, start = list(a = a, S = S, K= K), 
               data = test_data)
  

distance_predict <- predict(nls.mod, newdata = data.frame(ant.tag.distance = seq(0, 900, by = 20))) %>% 
  data.frame() %>% 
  rename("zpred" = 1) %>% 
  mutate(ant.tag.distance = seq(0, 900, by = 20))
} 
```

If we do this test using all the usable data (including from the nodes with the unexpected distance-signal strength relationship), we see quite poor predictive ability, as expected. Below we see the predicted distance compared to the true distance for these remaining 10% of signals.

```{r}
# try to predict distance with a simple linear model ----
distance_predict <- distance_tester(df_bearings_dist)

distance_predict %>%
  ggplot() +
  geom_point(aes(x = ant.tag.distance, y = predicted.distance)) +
  facet_wrap(date~NodeID) +
  geom_abline(intercept = 0) +
  lims(x = c(0, 225),
       y = c(0, 225)) +
  labs(y = "Predicted distance",
       x = "True distance",
       title = "All usable node data") +
  theme_bw()
```

```{r}
# cross validation ----
# K-fold cross-validation


# defining training control
# as cross-validation and
# value of K equal to 10
train_control <- trainControl(method = "cv",
							number = 10)

# training the model by assigning sales column
# as target variable and rest other column
# as independent variable
model_all_data <- train(ant.tag.distance ~ Signal + I(Signal^2), data = df_bearings_dist,
			method = "lm",
			trControl = train_control)

# printing model performance metrics
# along with other details
all_data_r2 <- model_all_data$results$Rsquared



model_good_data <- train(ant.tag.distance ~ Signal + I(Signal^2), data = df_bearings_dist_good,
			method = "lm",
			trControl = train_control)


good_data_r2 <- model_good_data$results$Rsquared

# just 10/25
df_bearings_dist_1025 <- filter
model_good_data <- train(ant.tag.distance ~ Signal + I(Signal^2), data = df_bearings_dist_good,
			method = "lm",
			trControl = train_control)


good_data_r2 <- model_good_data$results$Rsquared


pred_mod <- lm(ant.tag.distance ~ Signal + I(Signal^2), data = df_bearings_dist_good)

znewdat = data.frame(Signal = seq(min(df_bearings_dist_good$Signal), max(df_bearings_dist_good$Signal)))

zpred <- predict(pred_mod, newdata = znewdat, se.fit = TRUE) %>% 
  cbind(znewdat) %>% 
  mutate(lci = fit - (1.96 * se.fit),
         uci = fit + (1.96 * se.fit)) %>% 
  select(Signal, "pred.mean.dist" = fit, lci, uci)

saveRDS(zpred, here("data/node_signal_predicted_distance"))  

```

We can repeat this procedure multiple times and calculate a cross-validated estimate of the predictive ability of this model. Using all the useable data, the R-squared explaining how well the predicted distance matched the actual distance is only `r round(all_data_r2, 2)`


However, when we restrict this test to only the data that follow the expected distance-signal strength relationship, we can visually see that we get somewhat better predicted distance:

```{r}
# try to predict distance with a simple linear model ----


distance_predict_good <- distance_tester(df_bearings_dist_good)

distance_predict_good %>%
  ggplot() +
  geom_point(aes(x = ant.tag.distance, y = predicted.distance)) +
  facet_wrap(date~NodeID) +
  geom_abline(intercept = 0) +
  lims(x = c(0, 225),
       y = c(0, 225)) +
  labs(y = "Predicted distance",
       x = "True distance",
       title = "Good node data only") +
  theme_bw()
```

And the cross-validated r-squared value (`r round(good_data_r2, 2)`) indicates some improvement in how well the predicted distance matches the actual distance.


These first tests suggest there is some promise in using nodes to estimate tag location, but there remain some technical issues to figure out. In particular, a priority is determining why the data from 2 out of 3 nodes each day was suspect. As of Oct 20, this is partially solved- it appears the nodes that collected no usable data had insufficient charge in their batteries. It remains unclear why one node each day collected data showing either no relationship between signal strength and distance (node 365099 on Oct 18) or possibly a positive relationship (node 3680B7 on Sept 22). If these data represent correct node behavior, then we may not be able to accurately estimate the location of tagged birds in the wild. Furthermore, additional testing with multiple nodes operating correctly will help us know how well we can use signal strength from multiple nodes simultaneously to estimate tag location.




