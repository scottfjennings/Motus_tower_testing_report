---
title: ''
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r }

library(tidyverse)
library(gridExtra)
library(here)
library(AICcmodavg)
library(flextable)
library(officer)
library(lubridate)

# visualize and analyze ----

df_bearings_dist_ctt <- readRDS(here("data/all_pings_distance_bearing")) %>% 
  filter(mfg == "CTT", ) %>% 
  mutate(dist.group = case_when(ant.tag.distance < 2000 ~ "close",
                                ant.tag.distance > 2000 ~ "far"),
         detected = ifelse(is.na(sig), 0, 1),
         detected.label = ifelse(is.na(sig), "Interpolated", "Detected"))



```

# Methods  
## Tag details  
CTT only - David please fill in brief tag specs here: model name/number, nominal signal transmission interval.  

## Drone flights

We used DJI Matrise 100 UAVs for all test flights. We attached the tag in a vertical orientation to one of the UAV landing gear struts. We oriented the tag with the antenna pointing downward, and used electrical tape around the tag body and at 1-2 points along the tag's antenna.   

We did test flights at three locations along Tomales Bay: at the Cypress Grove and Toms Point Motus towers (Figure 1) we programmed the UAV's to fly a creeping line or parallel pattern, covering a 1 km radius circle centered at each tower. We programmed the parallel paths to be spaced 400 m apart, and the UAV to fly at 5 m/s and 50 m above the surface. We also flew 1-3 manual flights at ~ 10 m above the surface over specific areas of interest for our study at two locations: Cypress Grove and Walker Creek. The flights at Walker Creek were intentionally out of the line of sight for both towers. For all flights we collected UAV location data at > 1 hz.  


## Data processing  

A primary objective of this testing was to estimate the probability of a tag signal being detected as a function of distance from the Motus tower and the difference in bearing from tower to tag off the axis of each antenna. Thus we needed to identify any instances where a tag signal was expected but not detected, and add these interpollated signals back into the dataset. The tag was transmitting signal continuously during the test period, but the UAVs were flying in distinct flights lasting ~15 minutes according to battery life. We wanted to exclude tag signals detected between flights when batteries were exchanged. Grouping the tag signal data by UAV flight provided a convenient way to interpolate missed signals. We identified four types of missed tag signal that required slightly different interpollation methods: 1) signals transmitted after the start of the UAV flight but before the first detected signal; 2) signals transmitted between the first and last detected signals; 3) signals transmitted after the last detected signal but before the end of the flight; and 4) no signals were detected during the entire flight. For each of these types, we interpollated missed signals as occuring on a 14.8 sec interval, which was the average interval of detected signals in our data once we filtered to intervals 13 < x < 16 sec. This interpollation process was repeated for each antenna on each tower. Full details and code for our interpollation methods can be found in Appendix A : Data processing.  

Once missed signals were interpollated, we attributed each signal to the appropriate UAV location. We then calculated the distance and bearing between tag and tower for each signal (see Appendix a: Data processing for further detail). We then calculated the tag bearing off the axis of each antenna as the difference between the bearing of the antenna axis and the tag-tower bearing. We assumed that there would be no difference in signal detectability to the left vs right of the antenna axis, so we converted the tag bearing off antenna axis to the scale 0-180.  

## Analysis and visualization  

We first visually examing patterns in signal strength and detected/missed signal the raw data by plotting tag signals 1) along the mapped UAV flight path, and 2) as a function of distance and bearing off antenna axis.  

To generalize our results, we also fitted some simple linear models and generalized linear models to evaluate signal strength and detection probability, respectively, as a function of distance and bearing off antenna axis. We restricted this analysis to just the programmed-route flights done in each tower circle (excluding low altitude, manual flights at Cypress Grove and Walker Creek). We separated the data into "close" and "far" subsets and analyzed these subsets separately, because of the large gap with no data in the middle of our observed distance range (Figure 2). For each data subset (close and far) and each response variable (signal strength and detection probability) we fitted models with the interaction and additive effects of distance and tag bearing off antenna axis, the single main effects of these variables, and the intercept only model. We pooled detections across all antennae, and did not attempt to account for differences in detectability between antennae. We determined relative support for each model by comparing AICc values, and for supported models we extracted coefficient estimates and 95% Confidence Intervals to judge coefficient importance and strength in predicting response variables. We also used the best supported models to create estimated signal strength and detection probability surfaces across the distances and angles in our data.  


# Results and Discussion  
## Summarize and visualize raw data  
```{r}

flight_summ <- readRDS(here("data/drone_flight_times_antennae")) %>% 
  filter(mfg == "CTT") %>% 
  mutate(flight.loc = case_when(start.time < "2021-09-14 12:00:00" ~ "Cypress Grove",
                                start.time > "2021-09-14 12:00:00" & date == "2021-09-14" ~ "Walker Creek",
                                date == "2021-09-15" ~ "Toms Point"),
         flight.type = ifelse(flight.height == "high", "P", "M")) %>% 
  distinct(date, flight.num, flight.type, flight.loc, flight.length)



detect_summary <- df_bearings_dist_ctt %>% 
  count(date, drone, flight.num, name, antBearing, detected.label) %>% 
  pivot_wider(id_cols = c(date, drone, name, flight.num, antBearing), names_from = "detected.label", values_from = n) %>%
  mutate(across(c("Interpolated", "Detected"), ~replace_na(.x, 0)),
         out.col = paste(Detected + Interpolated, " (", Detected, "; ", Interpolated, ")", sep = ""),
         antenna = paste(name, "; ", round(antBearing, 1), sep = "")) %>% 
  pivot_wider(id_cols = c(date, flight.num), names_from = "antenna", values_from = out.col)

detec_flight_summary <- full_join(flight_summ, detect_summary) %>% 
  mutate(flight.length = flight.length/60,
         flight.length = round(flight.length, 1),
         date = paste(month(date), day(date), sep = "-"))

```


We conducted a total of eight programmed-route flgihts and four ad hoc flights between 0900-1300 hours on 14 and 15 Sept, 2021. Among these flights we detected a total of 3175 transmitted signals, and we interpollated another 1237 missed signals (Table 1).  


Table 1. Summary of UAV testing of Motus receiver detection rates on Tomales Bay, CA, 2021. Shown are flight characteristics and number of tag signals per antenna at each of two Motus towers (towers identified by the direction they point). Flight types are P = Programmed, M = Manual. For tag signals, values are Total (Detected; Interpolated).  
```{r}

detec_flight_summary <- detec_flight_summary %>% 
  mutate(filler.col1 = "",
         filler.col2 = "") %>% 
  select(date, flight.length, flight.loc, flight.type, filler.col1, contains("Cypress"), filler.col2, contains("Toms"))


colnames(detec_flight_summary) <- gsub("Cypress Grove; ", "", colnames(detec_flight_summary))
colnames(detec_flight_summary) <- gsub("Toms Point; ", "", colnames(detec_flight_summary))

flextable(detec_flight_summary) %>% 
  add_header_row(values = c("", "Flight characteristics", "", "Cypress Grove antennae", "", "Toms Point antennae"), colwidths = c(1, 3, 1, 4, 1, 4)) %>% 
  set_header_labels(date = "Date",
                    flight.length = "Duration (min)",
                    flight.loc = "Location",
                    flight.type = "Type",
                    filler.col1 = "",
                    filler.col2 = "") %>% 
  align(j = 2:ncol(detec_flight_summary), align = "center", part = "all") %>% 
  border_remove() %>% 
  border(i = 1, border.top = fp_border(color = "black"), part = "header") %>% 
  border(i = 2, j = 2:4, border.top = fp_border(color = "black"), part = "header") %>% 
  border(i = 2, j = 6:9, border.top = fp_border(color = "black"), part = "header") %>% 
  border(i = 2, j = 11:14, border.top = fp_border(color = "black"), part = "header") %>% 
  border(i = 1, border.top = fp_border(color = "black"), part = "body") %>% 
  border(i = nrow(detec_flight_summary), border.bottom = fp_border(color = "black"), part = "body") %>% 
  #width(j = 2:4, width = 1) %>% 
  #width(j = 6:9, width = 2) %>% 
  #width(j = 11:14, width = 2) %>% 
  autofit() %>% 
  fit_to_width(max_width = 8)
```


In examining detections as a function of distance and bearing off the antenna axis, we found somewhat predictable patterns of signal strength (Figure 2). Signal strength was greatest close the the tower and along bearings nearer the axis of the antenna. We also found fairly expected patterns in whether or not a signal was detected. Most tag signals were detected when the UAV was flying within approximately 1,800 m of a tower, and there was little effect of bearing off antenna axis at these distances. However, at distances between approximately 5,200-7,800 m, the bearing off antenna axis began to have a stronger effect on detectability. This effect of bearing off antenna axis was somewhat more apparent for antennae mounted on the Cypress Grove tower; whereas detectability was more constant across bearings for Toms Point antennae.   

We found encouraging results in the raw data plot for flights done at Walker Creek. Recall that these flights were intentionally done at a low elevation, with the line of sight blocked by one (Toms Point tower) or several (Cypress Grove) ridges. We observed relatively good detection during these flights by most antennae on the Toms Point tower, at a distance of approximately 2,000 m. Some signals were even detected by the two Cypress Grove antennae that are pointed toward Walker Creek, despite the substantial distance and blocking topography. Walker Creek is one of the main areas on Tomales Bay that shorebirds use, so we are pleased with these detections.  



Figure 2. Raw detections collected during UAV testing of Motus receivers on Tomales Bay, CA, 2021. Shown are detected and interpolated signals by a UAV-mounted tag flown in a series of flights at three locations. Signals are separated by the tower at which they were detected (or interpolated for) and by the location of the flight (see Figure 1). The blue scale indicates signal strength, and red indicates interpolated signals.  
```{r fig.dim = c(8, 6)}

# figure 2

ggplot() +
  geom_point(data = filter(df_bearings_dist_ctt, is.na(sig), mfg == "CTT"), aes(x = tag.ant.bearing.dif, y = ant.tag.distance, shape = flight.loc), color = "red") +
  geom_point(data = filter(df_bearings_dist_ctt, !is.na(sig), mfg == "CTT"), aes(x = tag.ant.bearing.dif, y = ant.tag.distance, color = sig, shape = flight.loc), size = 1) +
  facet_grid(paste(name, "tower")~wc) +
  scale_x_continuous(breaks = seq(0, 180, by = 30), labels = seq(0, 180, by = 30)) +
  labs(x = "Tag bearing off antenna axis",
       y = "Tag distance from tower",
       color = "Signal\nstrength",
       shape = "Flight\nlocation") +
  theme_bw()

```

```{r}
# analyze ----

# model selection

model_data <- df_bearings_dist_ctt %>% 
  filter(flight.loc != "Walker Creek")

zmodnames = c("Distance * Bearing", "Distance + Bearing", "Distance", "Bearing", "Intercept only")

sig.str.close <- list(dist.bear = model_data %>%
                        filter(dist.group == "close", !is.na(sig)) %>%
                        lm(sig ~ ant.tag.distance * tag.ant.bearing.dif, data = .),
                      dist_bear = model_data %>%
                        filter(dist.group == "close", !is.na(sig)) %>%
                        lm(sig ~ ant.tag.distance + tag.ant.bearing.dif, data = .),
                      dist = model_data %>%
                        filter(dist.group == "close", !is.na(sig)) %>%
                        lm(sig ~ ant.tag.distance, data = .),
                      bear = model_data %>%
                        filter(dist.group == "close", !is.na(sig)) %>%
                        lm(sig ~ tag.ant.bearing.dif, data = .),
                      int = model_data %>%
                        filter(dist.group == "close", !is.na(sig)) %>%
                        lm(sig ~ 1, data = .))


sig.str.close.aic <- aictab(sig.str.close, modnames = zmodnames) %>% 
  data.frame()  %>% 
  select(Modnames, K, AICc, Delta_AICc, AICcWt, LL) %>% 
  mutate(across(c("AICc", "Delta_AICc", "AICcWt", "LL"), ~round(.x, 2)))



sig.str.far <- list(dist.bear = model_data %>%
                        filter(dist.group == "far", !is.na(sig)) %>%
                        lm(sig ~ ant.tag.distance * tag.ant.bearing.dif, data = .),
                      dist_bear = model_data %>%
                        filter(dist.group == "far", !is.na(sig)) %>%
                        lm(sig ~ ant.tag.distance + tag.ant.bearing.dif, data = .),
                      dist = model_data %>%
                        filter(dist.group == "far", !is.na(sig)) %>%
                        lm(sig ~ ant.tag.distance, data = .),
                      bear = model_data %>%
                        filter(dist.group == "far", !is.na(sig)) %>%
                        lm(sig ~ tag.ant.bearing.dif, data = .),
                      int = model_data %>%
                        filter(dist.group == "far", !is.na(sig)) %>%
                        lm(sig ~ 1, data = .))


sig.str.far.aic <- aictab(sig.str.far, modnames = zmodnames) %>% 
  data.frame()  %>% 
  select(Modnames, K, AICc, Delta_AICc, AICcWt, LL) %>% 
  mutate(across(c("AICc", "Delta_AICc", "AICcWt", "LL"), ~round(.x, 2)))



# 2 chance of detection

detec.close <- list(dist.bear = model_data %>%
                    filter(dist.group == "close") %>%
                    glm(detected ~ ant.tag.distance * tag.ant.bearing.dif, data = ., family = binomial),
                  dist_bear = model_data %>%
                    filter(dist.group == "close") %>%
                    glm(detected ~ ant.tag.distance + tag.ant.bearing.dif, data = ., family = binomial),
                  dist = model_data %>%
                    filter(dist.group == "close") %>%
                    glm(detected ~ ant.tag.distance, data = ., family = binomial),
                  bear = model_data %>%
                    filter(dist.group == "close") %>%
                    glm(detected ~ tag.ant.bearing.dif, data = ., family = binomial),
                  int = model_data %>%
                    filter(dist.group == "close") %>%
                    glm(detected ~ 1, data = ., family = binomial))


detec.close.aic <- aictab(detec.close, modnames = zmodnames) %>% 
  data.frame()  %>% 
  select(Modnames, K, AICc, Delta_AICc, AICcWt, LL) %>% 
  mutate(across(c("AICc", "Delta_AICc", "AICcWt", "LL"), ~round(.x, 2)))



detec.far <- list(dist.bear = model_data %>%
                    filter(dist.group == "far") %>%
                    glm(detected ~ ant.tag.distance * tag.ant.bearing.dif, data = ., family = binomial),
                  dist_bear = model_data %>%
                    filter(dist.group == "far") %>%
                    glm(detected ~ ant.tag.distance + tag.ant.bearing.dif, data = ., family = binomial),
                  dist = model_data %>%
                    filter(dist.group == "far") %>%
                    glm(detected ~ ant.tag.distance, data = ., family = binomial),
                  bear = model_data %>%
                    filter(dist.group == "far") %>%
                    glm(detected ~ tag.ant.bearing.dif, data = ., family = binomial),
                  int = model_data %>%
                    filter(dist.group == "far") %>%
                    glm(detected ~ 1, data = ., family = binomial))


detec.far.aic <- aictab(detec.far, modnames = zmodnames) %>% 
  data.frame() %>% 
  select(Modnames, K, AICc, Delta_AICc, AICcWt, LL) %>% 
  mutate(across(c("AICc", "Delta_AICc", "AICcWt", "LL"), ~round(.x, 2)))



all_aic <- rbind(data.frame(Modnames = "Signal strength, close detections", K = "", AICc = "", Delta_AICc = "", AICcWt = "", LL = ""),
                 sig.str.close.aic, 
                 data.frame(Modnames = "Signal strength, far detections", K = "", AICc = "", Delta_AICc = "", AICcWt = "", LL = ""),
                 sig.str.far.aic,
                 data.frame(Modnames = "Detection probability, close detections", K = "", AICc = "", Delta_AICc = "", AICcWt = "", LL = ""),
                 detec.close.aic, 
                 data.frame(Modnames = "Detection probability, far detections", K = "", AICc = "", Delta_AICc = "", AICcWt = "", LL = ""),
                 detec.far.aic)
```


## Models  

In comparing support for the candidate models, the structure with the interaction between distance and bearing off antenna axis was best supported across all four subsets of the data (close and far distances for signal strength and detection probability responses). Additionally for all four data subsets, the `r\u0394` AICc values for second ranked models were large (but see detection probability, far), so we base inference on the best supported model in each subset only.  

Table 2. Model selection results for UAV testing of Motus receiver detection rates on Tomales Bay, CA, 2021. Model selection was done separately for each of four data subsets, indicated by the subheadings. K is the number of model parameters, AICc is the Akaiki Information Criterion value corrected for small sample size, `r\u0394` AICc is the difference in AICc value between the current model and the one with the lowest AICc value, AICc Wt. is the AICc model weight, and ln(likelihood) is the log-transformed maximized likelihood for each model.  
```{r}
subtab.nrow = nrow(detec.close.aic)
flextable(all_aic) %>% 
  set_header_labels(Modnames = "Model structure",
                    Delta_AICc = "\u0394 AICc",
                    AICcWt = "AICc Wt.",
                    LL = "ln(likelihood)") %>%  
  # sig.close aic subtable formatting
  #merge_at(i = 1, j = 1:2, part = "body") %>% 
  border(i = 1, j = 1, border.bottom = fp_border(color = "black"), part = "body") %>% 
  border(i = 1 + subtab.nrow, border.bottom = fp_border(color = "black"), part = "body")  %>% 
  # sig.far aic subtable formatting
  #merge_at(i = 2 + subtab.nrow, j = 1:2, part = "body") %>% 
  border(i = 2 + subtab.nrow, j = 1, border.bottom = fp_border(color = "black"), part = "body") %>% 
  border(i = 2 + (2 *subtab.nrow), border.bottom = fp_border(color = "black"), part = "body")  %>% 
  # detec.close aic subtable formatting
  #merge_at(i = 3 + (2 *subtab.nrow), j = 1:2, part = "body") %>% 
  border(i = 3 + (2 *subtab.nrow), j = 1, border.bottom = fp_border(color = "black"), part = "body") %>% 
  border(i = 3 + (3 *subtab.nrow), border.bottom = fp_border(color = "black"), part = "body") %>% 
  # detec.far aic subtable formatting
  #merge_at(i = 4 + (3 *subtab.nrow), j = 1:2, part = "body") %>% 
  border(i = 4 + (3 *subtab.nrow), j = 1, border.bottom = fp_border(color = "black"), part = "body") %>% 
  border(i = 4 + (4 *subtab.nrow), border.bottom = fp_border(color = "black"), part = "body") %>% 
  width(j = 1, width = 2.5) %>% 
  autofit() %>% 
  align(j = 2:6, align = "center")

```



The estimates and 95% confidence intervals for coefficients in the best supported models, and the predicted detection surfaces derived from those models, generally support our qualitative conclusions drawn from the plotted raw data. In general, we found a negative relationship between distance from tower and both signal strength and detection probability (Table 2, Figure 3). We also generally found a negative relationship between bearing off antenna axis and signal strength, but this relationship was less well supported for detection probability (i.e. 95% CI overlapping 0).  


```{r}
# best model coefs and CI

get_ci_coef <- function(mod, mod.name) {
  ci_coef <- cbind(coef(mod), confint(mod)) %>% 
    data.frame() %>% 
    rename(est = 1) %>% 
    rownames_to_column("coef") %>% 
    mutate(model = mod.name) %>% 
    filter(coef != "(Intercept)")
return(ci_coef)
  }

all_ci_coef <- map2_df(list(sig.str.close$dist.bear, sig.str.far$dist.bear, detec.close$dist.bear, detec.far$dist.bear), 
                      list("Signal strength, close", "Signal strength, far", "Detection probability, close", "Detection probability, far"),
                      get_ci_coef) %>% 
  data.frame() %>% 
  mutate(coef = case_when(coef == "ant.tag.distance" ~ "Distance",
                          coef == "tag.ant.bearing.dif" ~ "Bearing",
                          coef == "ant.tag.distance:tag.ant.bearing.dif" ~ "Distance * Bearing"),
         across(c("est", "X2.5..", "X97.5.."), ~round(.x, 5)),
         model = ifelse(coef == "Distance", model, "")) %>% 
  select(model, coef, est, X2.5.., X97.5..)


flextable(all_ci_coef) %>% 
  set_header_labels("model" = "Data subset",
                    "coef" = "Coefficient",
                    "est" = "Estimate",
                    "X2.5.." = "lower",
                    "X97.5.." = "upper") %>% 
  add_header_row(values = c("", "95% Confidence Interval"), colwidths = c(3, 2)) %>% 
  border_remove() %>% 
  border(i = 1, border.top = fp_border(color = "black"), part = "header") %>% 
  border(i = 1, j = 4:5, border.bottom = fp_border(color = "black"), part = "header") %>% 
  border(i = 1, border.top = fp_border(color = "black"), part = "body") %>% 
  border(i = c(3, 6, 9), border.bottom = fp_border(color = "black"), part = "body") %>% 
  border(i = nrow(all_ci_coef), border.bottom = fp_border(color = "black"), part = "body") %>% 
  width(j = 1:2, width = 2) %>% 
  align(j = 3:5, align = "center", part = "all")



```



```{r}
# model estimates for probability of detection
# using only the non-walker creek flights/models: detec.wcf.close and detec.wcf.far


# close and far newdats
close_newdat <- expand.grid(ant.tag.distance = seq(min(filter(model_data, dist.group == "close")$ant.tag.distance),
                                                   max(filter(model_data, dist.group == "close")$ant.tag.distance),
                                                   length.out = 100),
                            tag.ant.bearing.dif = seq(0, 180, length.out = 100))

far_newdat <- expand.grid(ant.tag.distance = seq(min(filter(model_data, dist.group == "far")$ant.tag.distance),
                                                 max(filter(model_data, dist.group == "far")$ant.tag.distance),
                                                 length.out = 100),
                          tag.ant.bearing.dif = seq(0, 180, length.out = 100))


# signal strength predictions
# close
sig.str.close_pred <- predict(sig.str.close$dist.bear, close_newdat) %>% 
  cbind(close_newdat) %>% 
  rename(sig.str = 1)

# far
sig.str.far_pred <- predict(sig.str.far$dist.bear, far_newdat) %>% 
  cbind(far_newdat) %>% 
  rename(sig.str = 1)


# detection probability predictions
# close
detec.close_pred <- predict.glm(detec.close$dist.bear, close_newdat, type = "response") %>% 
  cbind(close_newdat) %>% 
  rename(detec.prob = 1)



# far
detec.far_pred <- predict.glm(detec.far$dist.bear, far_newdat, type = "response") %>% 
  cbind(far_newdat) %>% 
  rename(detec.prob = 1)
```


```{r}
# plots
ggplot() +
  geom_contour_filled(data = sig.str.close_pred, aes(tag.ant.bearing.dif, ant.tag.distance, z = sig.str), binwidth = 10) +
  labs(x = "",
       y = "Tag distance from tower (m)",
       title = "Signal strength, close") +
  scale_fill_brewer(palette = "Blues", name = "Predicted\nsignal\nstrength", direction=-1, guide = guide_legend(reverse = TRUE)) +
  theme_bw() +
  coord_polar() +
  scale_x_continuous(limits = c(0,360), breaks = seq(0, 180, by = 30), labels = seq(0, 180, by = 30))
```


```{r}
ggplot() +
  geom_contour_filled(data = sig.str.far_pred, aes(tag.ant.bearing.dif, ant.tag.distance, z = sig.str), binwidth = 10) +
  labs(x = "",
       y = "Tag distance from tower (m)",
       title = "Signal strength, far") +
  scale_fill_brewer(palette = "Blues", name = "Predicted\nsignal\nstrength", direction=-1, guide = guide_legend(reverse = TRUE)) +
  theme_bw() +
  coord_polar() +
  scale_x_continuous(limits = c(0,360), breaks = seq(0, 180, by = 30), labels = seq(0, 180, by = 30))
```


```{r}

ggplot() +
  geom_contour_filled(data = detec.close_pred, aes(tag.ant.bearing.dif, ant.tag.distance, z = detec.prob)) +
  coord_polar() +
  scale_x_continuous(limits = c(0,360), breaks = seq(0, 180, by = 30), labels = seq(0, 180, by = 30)) +
  labs(x = "",
       y = "Tag distance from tower (m)",
       title = "Detection probability, close") +
  scale_fill_brewer(palette = "BuPu", name = "Predicted\nprobability\nof tag\ndetection", guide = guide_legend(reverse = TRUE)) +
   scale_color_manual(values = c("black", "red")) +
  theme_bw()

```


```{r}
ggplot() +
  geom_contour_filled(data = detec.far_pred, aes(tag.ant.bearing.dif, ant.tag.distance, z = detec.prob)) +
  coord_polar() +
  scale_x_continuous(limits = c(0,360), breaks = seq(0, 180, by = 30), labels = seq(0, 180, by = 30)) +
  labs(x = "",
       y = "Tag distance from tower (m)",
       title = "Detection probability, far") +
  scale_fill_brewer(palette = "PuOr", name = "Predicted\nprobability\nof tag\ndetection", guide = guide_legend(reverse = TRUE)) +
   scale_color_manual(values = c("black", "red")) +
  theme_bw()
```


